---
description: Apply when working with React frontend code in the frontend-react/ directory. Covers data fetching, state management, i18n, privacy mode, and component patterns.
globs: ["frontend-react/**"]
---

# Frontend Standards (React + TypeScript)

## API Types (OpenAPI Codegen)
- Types in `src/api/types/` are barrel modules re-exporting from `./generated`. Do NOT manually define types that have a backend Pydantic `response_model`.
- `generated.d.ts` is gitignored, auto-regenerated by `npm run build`/`npm run dev`.
- Access: `import type { components } from "./generated"` → `type Foo = components["schemas"]["FooModel"]`.
- **This rule applies to request types too.** If a backend Pydantic schema exists for a request body (e.g. `UpdateHoldingRequest`), use the codegen type. If the backend is missing a dedicated schema, add it in `backend/api/schemas.py` first, then run `make generate-api`. Hand-written request types are only allowed for endpoints that return untyped dicts with no backend schema.

## Data Fetching
- TanStack Query for all API calls. Never raw `fetch`/`axios` in components.
- `useMutation` for writes; invalidate related queries on success.
- API client: `import { apiClient } from "src/api/client"` — never import `axios` directly.
- Before writing new hooks, check existing patterns in `src/api/hooks/`.

## State Management
- **Server state:** TanStack Query. **Global UI:** Zustand (`usePrivacyMode`, `useTheme`). **Local:** `useState`.
- Avoid prop-drilling >2 levels — use Zustand.
- **Syncing server state into local state:** Use `useEffect` with the server value in the dependency array. Never use `useState(serverValue)` + render-time reference comparison (`prevX !== x`) — this pattern silently breaks when data is already loaded at component mount time (e.g. a component inside a lazy `TabsContent` that mounts after data is fetched).

## Constants & i18n
- All constants in `src/lib/constants.ts`. No magic strings or inline constant arrays.
- All user-facing strings: `useTranslation()` + `t("key")`. Locale files: `public/locales/{en,ja,zh-CN,zh-TW}/`.
- Key naming: dot-notation by page (e.g., `radar.add_stock`). Interpolation: `t("key", { variable })`.
- **Frontend owns all display-label translation.** Backend endpoints must return machine-readable enum keys (e.g. `"low"`, `"moderate"`) for labels the UI will render; the frontend translates via `t()`. If a backend endpoint must return pre-translated text (long-form advice, disclaimers), include `i18n.language` in the TanStack Query key so the cache invalidates when the user changes language.
- **All persisted user preferences must be hydrated on app startup.** When a preference is stored on the server (e.g. `language`, `privacy_mode`), it must be read from `GET /settings/preferences` and applied on load (see `AppSidebar`). Never leave a preference hydrated for one setting but not another — they must be kept symmetrical.

## Project-Specific Hooks
- **Privacy:** `usePrivacyMode()` — Zustand store, single source of truth for all pages.
  - Read privacy state via `useIsPrivate()` (boolean selector) or `usePrivacyMode((s) => s.isPrivate)`.
  - Mask values: `isPrivate ? "***" : formattedValue`; currency shorthand: `maskMoney(value)`.
  - **NEVER** read `privacy_mode` from the server preferences API directly in a component — only the Zustand store is authoritative.
  - On app startup, the sidebar hydrates the store from `GET /settings/preferences`. Toggle changes are persisted to `PUT /settings/preferences` automatically.
- **Theme:** `useTheme()` — Zustand, persisted to `localStorage` as `folio-theme`. Dark mode via `.dark` class on `<html>`.
- **Charts:** `useRechartsTheme()` for Recharts, `useLightweightChartTheme()` for TradingView charts.

## Components & Styling
- Base: shadcn/ui. Loading: `<Skeleton>`. Empty: `<EmptyState>`. Errors: `<ErrorBoundary>` via `PageShell`. Toast: `sonner`.
- Tailwind only (no inline styles). Dark: `dark:` variants. Responsive: `sm:`/`md:`/`lg:` with mobile-first grids.

## Testing (Vitest + React Testing Library)

Every new utility function, hook, and component MUST ship with tests. Run `make frontend-test` or `npm test` to verify.

### File placement and naming
- Co-locate tests in a `__tests__/` subdirectory next to the source file.
- Name: `<ModuleName>.test.ts` (pure functions/hooks) or `<ModuleName>.test.tsx` (components).
- Examples: `src/lib/__tests__/utils.test.ts`, `src/hooks/__tests__/usePrivacyMode.test.ts`, `src/components/__tests__/EmptyState.test.tsx`.

### What to test per type

| Type | What to test |
|---|---|
| Utility functions (`lib/`) | All branches of pure logic; edge cases |
| Zustand hooks (`hooks/`) | Initial state, mutations, and side effects (e.g., DOM class changes) |
| API query hooks (`api/hooks/`) | Loading state, endpoint called, response shape |
| API mutation hooks (`api/hooks/`) | Endpoint called with correct payload, success state |
| UI components (`components/`) | Renders key content, user interactions, conditional rendering |
| Constants (`lib/constants.ts`) | Entry counts, set non-overlap, key presence |

### Canonical patterns

**Component test** (`src/components/__tests__/EmptyState.test.tsx`):
```tsx
import { render, screen } from "@testing-library/react";
import userEvent from "@testing-library/user-event";
import { vi } from "vitest";

it("calls handler on click", async () => {
  const handler = vi.fn();
  render(<MyComponent onClick={handler} />);
  await userEvent.setup().click(screen.getByRole("button"));
  expect(handler).toHaveBeenCalledOnce();
});
```

**API hook test** (`src/api/hooks/__tests__/useRadar.test.ts`):
```ts
vi.mock("@/api/client", () => ({ default: { get: vi.fn(), interceptors: { request: { use: vi.fn() } } } }));

function createWrapper() {
  const qc = new QueryClient({ defaultOptions: { queries: { retry: false } } });
  return ({ children }: { children: React.ReactNode }) =>
    createElement(QueryClientProvider, { client: qc }, children);
}
```

**Zustand store test** (`src/hooks/__tests__/usePrivacyMode.test.ts`):
```ts
beforeEach(() => { usePrivacyMode.setState({ isPrivate: false }); }); // reset between tests
```

### Coverage thresholds (ratchet — only ever increase)

Configured in `frontend-react/vitest.config.ts` under `coverage.thresholds`:

| Metric | Current floor |
|---|---|
| Lines | 4% |
| Branches | 60% |
| Functions | 25% |
| Statements | 4% |

`src/components/ui/` is excluded from the coverage denominator — those are third-party shadcn/ui wrappers with no project logic to test.

When coverage improves, bump the threshold values and commit them as the new floor.

### vi.hoisted() for shared mock state

When a `vi.mock()` factory needs to reference a `vi.fn()` defined outside the factory, use `vi.hoisted()` — otherwise `vi.mock` is hoisted before the variable is initialized:

```ts
const { mockFn } = vi.hoisted(() => ({ mockFn: vi.fn() }))
vi.mock("some-module", () => ({ default: { method: mockFn } }))
```

### Do NOT
- Hit real APIs or network in tests — always mock `@/api/client`.
- Use `setTimeout` or `sleep` — use `waitFor()` from `@testing-library/react`.
- Import `describe`/`it`/`expect` explicitly — `globals: true` is set in `vitest.config.ts`.
- Test `src/components/ui/` primitives — they are third-party and excluded from coverage.
