---
description: Clean Code, Clean Architecture, general rules, and backend testing standards
alwaysApply: true
---

# Coding Standards — Clean Code + Clean Architecture

## Working with Existing Code
-   Before writing new modules, check existing files in the same layer for patterns to follow.
-   Reference actual files as examples (e.g., `backend/api/stock_routes.py` for route patterns, `backend/infrastructure/repositories.py` for repository patterns).
-   When in doubt, match the style of the nearest existing file rather than inventing a new convention.

## Clean Architecture (Layered Structure)
-   **`domain/`** — Pure business rules, entities, enums, constants. No framework imports allowed.
-   **`application/`** — Use-case orchestration and service functions. Depends only on `domain/` and repository interfaces.
-   **`infrastructure/`** — External adapters (yfinance, Telegram, SQLite repositories). Implements interfaces defined by upper layers.
-   **`api/`** — FastAPI route handlers. Thin controllers that delegate to `application/` services.
-   New code must be placed in the correct layer; never leak infrastructure concerns into `domain/`.

## Clean Code Practices
-   **Small, focused functions:** Each function should do one thing well with a descriptive name.
-   **No magic numbers or strings:** Use `domain/constants.py` (backend) and `frontend/config.py` (frontend) for all thresholds, TTLs, labels, and messages.
-   **DRY (Don't Repeat Yourself):** Extract duplicated logic into shared helpers or modules.
-   **Pure functions:** Prefer pure functions and immutable data where possible; isolate side effects at the boundary.

## General Rules
-   **Type Safety:** Use Pydantic models and Python type hints everywhere.
-   **Graceful Error Handling:** Never crash on external API failures (e.g., if yfinance fails, return None/Warning, don't break the app).
-   **Language:** User Interface and Logs must be in **Traditional Chinese (繁體中文)**.
-   **Documentation Sync:** Any feature addition, modification, or removal MUST include updates to the corresponding documentation:
    -   `README.md` — Update feature list, API reference, architecture diagrams, examples, and project structure as needed.
    -   Frontend SOP manual (the `st.expander("SOP")` block in `frontend/pages/radar.py`) — Update the in-app user guide to reflect the current system behavior.
    -   OpenClaw Skills (`scripts/openclaw/folio/SKILL.md` and `scripts/openclaw/AGENTS.md`) — Update endpoint tables, webhook actions, categories, and usage tips to match API changes.
    -   Never leave documentation out of date after a code change.

## Python Tooling
-   **Python version:** 3.12+ (match CI in `.github/workflows/ci.yml`).
-   **Formatter/Linter:** Use `ruff` for both formatting and linting. Run `ruff check --fix` and `ruff format` before committing.
-   **Import ordering:** stdlib, third-party, local — ruff handles this automatically.
-   **Makefile shortcuts:** Use `make test`, `make lint`, `make format` from the project root. Run `make help` to see all targets.
-   **Dependencies:** Pin versions in `requirements.txt`. When adding a new package, add it with a pinned version.

## Logging
-   Use `from logging_config import get_logger` and `logger = get_logger(__name__)` in every backend module.
-   Never use `print()` for diagnostic output; always use `logger.info()` / `logger.warning()` / `logger.error()`.
-   Log messages in Traditional Chinese, consistent with UI language.
-   Log levels: DEBUG for tracing, INFO for business events, WARNING for recoverable issues, ERROR for failures.

## Security
-   Never hardcode secrets, API keys, or tokens in source code.
-   Use `os.getenv()` with `python-dotenv` for all configuration. Reference `.env.example` for required variables.
-   Never commit `.env` files. Only commit `.env.example` with placeholder values.

---

# Backend Testing Standards (pytest)

Every feature MUST ship with tests. No untested code in production.

## Test File Structure

Tests live in `backend/tests/` mirroring the source layout. Check the actual directory for current structure.

## Test Naming

Use descriptive names: `test_<function>_should_<expected_behavior>`

```python
# ✅ GOOD
def test_create_stock_should_return_409_when_duplicate(): ...
def test_webhook_signals_should_return_rsi_and_ma(): ...

# ❌ BAD
def test_stock(): ...
def test_1(): ...
```

## AAA Pattern

Every test follows **Arrange / Act / Assert**:

```python
def test_deactivate_stock_should_record_reason():
    # Arrange
    client.post("/ticker", json={"ticker": "NVDA", "category": "Growth", "thesis": "AI leader"})

    # Act
    resp = client.post("/ticker/NVDA/deactivate", json={"reason": "Valuation too high"})

    # Assert
    assert resp.status_code == 200
    assert "NVDA" in resp.json()["message"]
```

## Fixtures & conftest.py

- `conftest.py` provides: `TestClient`, in-memory SQLite DB, mock yfinance data, mock Telegram sender.
- Use `@pytest.fixture` with appropriate scope (`session` for DB, `function` for per-test isolation).

## Mock External Services

- **yfinance**, **Telegram Bot API**, and any network I/O MUST be mocked. Never hit real APIs in tests.
- Use `unittest.mock.patch` or `pytest-mock` to replace infrastructure adapters.

## Minimum Test Coverage Per Endpoint

| Scenario | Status Code |
|----------|-------------|
| Happy path | 200 / 201 |
| Validation error | 422 |
| Not found | 404 |
| Conflict / duplicate | 409 (where applicable) |

## Webhook Action Coverage

- Every webhook action MUST have at least **one happy-path test** and **one error-path test**.
- The `help` action must be tested to ensure discoverability stays accurate.

## Mandatory Coverage Rule

- Every new feature or bug fix MUST include corresponding tests.
- PRs that change business logic without adding or updating tests should be flagged during review.
